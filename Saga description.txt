Maccount Микросервис управления УЗ пользователей (БД account - таблицы user, e-wallet)
Morder Микросервис заказов (БД e-market - таблица order)
Mproduct Микросервис учета товаров (БД e-market - таблицы product_desc, product_accounting (count, price))
Mmoney Микросервис для списывания средств с электронного кошелька (БД account - таблицы user, e-wallet)

- реализация в будущем систему оплаты:
# MmoneyAdd Микросервис для пополнения электронного кошелька (БД account - таблицы user, e-wallet) - Обеспечение гарантии зачисления списанных средств, хранение состояния транзакции в БД (рассмотреть другие способы).
# Mbank - внешний сервис, "банк", который хранит денежные средства на счетах клиентов, через API позволяет запросить - достаточно ли средств для оплаты, заморозить необходимую сумму, сделать списание в счет магазина (MmoneyAdd пополняет электронный кошелёк клиента), при потверждении операции клиентом. 

Микросервис (хореограф) - 
- принимает заказ, создаёт событие "create order":
	Morder (подписка на событие "create order"): регистрирует заказ (если ошибка, отправляет отрицательный ответ "fail created order"), создаёт событие "created order"
	Choreograph (подписан на события "created order", "fail created order") создаёт событие "check product"
	Mproduct (подписка на событие "check product"): проверяет наличие товара (в случае отсутствия, отменяет заказ, отправляет отрицательный ответ "fail checked product") создаёт событие "checked product",
	Choreograph (подписан на события "checked product", "fail checked product") если событие "checked product", создаёт событие "waiting for payment", если событие "fail checked product", создаёт событие "delete order"
	Morder если событие "waiting for payment", меняет статус заказа на ожидание оплаты, если событие "fail checked product", отменяет заказ, меняет статус на delete order, создаёт событие "deleted order"
	Choreograph отдаёт ответ клиенту
- асинхронное ожидание оплаты на стороне Микросервиса (хореографа) создаётся по наступлению события "waiting for payment". ожидает событие "start of payment" в течение 5 минут, отменяет компенсацию предыдущей части транзакции, если оно наступает. если событие не наступает, создаёт событие "no payment confirmation"
- в случае подтверждения оплаты создаётся событие "start of payment"
	Morder (подписан на событие "start of payment") подтвердить начало оплаты, меняет статус заказа на "start of payment", создает событие "check product availability"
	Сделать внутри локальной транзакции {
	Mproduct (подписан на событие "check product availability") проверяет наличе товара (-||-||-), создаёт событие "order booking"
	Mproduct (подписан на событие "order booking") временно бронирует заказ (в случае отсутствия, так же компенсация, что и в предыдущем шаге), создаёт событие "check money"
	}
	Сделать внутри локальной транзакции {
	Mmoney (подписан на событие "check money") проверяет средства на кошельке(если не хватает - отмена брони и т.д. вниз по цепочке), создаёт событие "freeze money"
	Mmoney (подписан на событие "freeze money") временно замораживает необходимую часть средств (если ошибка - та же компенсация, что и на предыдущем шаге), создаёт событие "debiting money"
	Mmoney (подписан на событие "debiting money") списывает средства (если ошибка, отмета заморозки и т.д.), создание события "final order registration"
	}
	Morder (подписан на событие "final order registration") регистрирует заказ, как оплаченный, завершает транзакцию успешно, статус "completed", отправляет асинхронный ответ пользователю (вывод статуса заказа из БД в ЛК).
- Микросервис (хореограф) подписан на событие "no payment confirmation" - отменяет операции по созданию заказа и отправляет асинхронный ответ клиенту (вывод статуса заказа из БД в ЛК).


Личный кабинет клиента простой список, где каждая строка: id заказа, статус заказа (принят в обработку, обрабатывается, ждёт оплаты, создан).


Разработка:
Тесты: 
 - на контроллеры, 
 - на запись/чтение из базы, 
 - интеграционные, +
 - на методы бизнес-логики
Прикрутить фронтенд сервер для имеющегося функционала:
 - Доработать шаблон под текущую задачу
 - Разместить и протестировать фронтент в докер-контейнере
 - Добавить контейнер в compose конфигурацию
Изучить прокидывание эксепшена и использование блока catch в случае использования прокси классов и обёрток (в том чител AOP), скрывающих под собой конструкцию try/catch
Изучить статью по микросервисам с использованием актуатора.
Разработать авторизацию:
 - Добавить микросервис авторизации в отдельном докер-контейнере
 - Разработать схему взаимодействия сервиса авторизации и всех остальных через JWT токены
 - Реализовать сервис авторизации
 - Добавить контейнер в compose конфигурацию

Рефакторинг:
Изучить материал по синхронным ответам через Kafka. Оптимизировать свою реализацию.
Изучить материал по callback. Реализовать идею с прерыванием события по расписанию.
Решить проблему с тестами consumers, прийти к решению без ожидания через sleep()

Доработка (на будущее):
создать общую схему на уровне микросервисов
создать схему на уровне компонентов, для каждого микросервиса


Баги:
Решить баг с тестом consumeMessageAboutDeletedOrderTest() при проверке assertTrue(messageConsumed); в class ConsumerOrderImplTest - возможно связано с проблемой с тестами consumers из Рефакторинга

CONSTRAINT firstkey 